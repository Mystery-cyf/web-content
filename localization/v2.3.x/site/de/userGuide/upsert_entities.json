{"codeList":["# Generate data to upsert\nimport random\nnb = 3000\ndim = 8\nvectors = [[random.random() for _ in range(dim)] for _ in range(nb)]\ndata = [\n    [i for i in range(nb)],\n    [str(i) for i in range(nb)],\n    [i for i in range(10000, 10000+nb)],\n    vectors,\n    [str(\"dy\"*i) for i in range(nb)]\n]\n","nEntities:= 3000\ndim:= 8\nidList:= make([]int64, 0, nEntities)\nrandomList:= make([]float64, 0, nEntities)\nembeddingList := make([][]float32, 0, nEntities)\n\nfor i := 0; i < nEntities; i++ {\n    idList = append(idList, int64(i))\n}\n    \nfor i := 0; i < nEntities; i++ {\n    randomList = append(randomList, rand.Float64())\n}\n  \nfor i := 0; i < nEntities; i++ {\n    vec := make([]float32, 0, dim)\nfor j := 0; j < dim; j++ {\n        vec = append(vec, rand.Float32())\n    }\n    embeddingList = append(embeddingList, vec)\n}\nidColData := entity.NewColumnInt64(\"ID\", idList)\nrandomColData := entity.NewColumnDouble(\"random\", randomList)\nembeddingColData := entity.NewColumnFloatVector(\"embeddings\", dim, embeddingList)\n","from pymilvus import Collection\ncollection = Collection(\"book\") # Get an existing collection.\nmr = collection.upsert(data)\n","if _, err := c.Upsert(ctx, collectionName, \"\", idColData, embeddingColData);\nerr != nil {\n        log.Fatalf(\"failed to upsert data, err: %v\", err)\n}\n"],"headingContent":"","anchorList":[{"label":"Upsert Entities","href":"Upsert-Entities","type":1,"isActive":false},{"label":"Prepare data","href":"Prepare-data","type":2,"isActive":false},{"label":"Upsert data","href":"Upsert-data","type":2,"isActive":false},{"label":"Flush data","href":"Flush-data","type":2,"isActive":false},{"label":"Limits","href":"Limits","type":2,"isActive":false},{"label":"What's next","href":"Whats-next","type":2,"isActive":false}]}